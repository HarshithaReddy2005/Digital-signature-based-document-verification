# Digital-signature-based-document-verification
This project focuses on implementing a digital signature verification system that combines the SHA-256 hashing algorithm with RSA encryption. It enables a sender to sign a digital document using their private RSA key, and a receiver to verify that signature using the sender’s public key. The system ensures that the document remains unaltered during transmission and confirms the authenticity of the sender, forming a secure channel of trust between parties.

To get started with this project, users should have Python 3.x installed on their machine. Additionally, the project requires the SymPy library for mathematical operations, which can be installed via pip install sympy. The hashlib module is used for SHA-256 hashing and is included by default in Python’s standard library. A basic understanding of cryptographic concepts such as RSA encryption, digital signatures, and hashing functions will be beneficial for following the project logic.

SHA-256, or Secure Hash Algorithm 256-bit, is a one-way cryptographic hash function that transforms any input into a fixed-size 256-bit hash value. It is widely regarded for its security properties, such as collision resistance—making it highly unlikely for two different inputs to produce the same hash—and pre-image resistance, which ensures it is nearly impossible to reconstruct the original input from its hash. These characteristics make SHA-256 an excellent choice for verifying data integrity. In this project, SHA-256 is used to generate a hash of the document before applying RSA encryption to create the digital signature.

The RSA key generation process begins with selecting two large prime numbers, p and q. Their product, n = p × q, serves as part of both the public and private keys. The totient φ(n) is calculated as (p − 1)(q − 1). A public exponent e is then selected such that 1 < e < φ(n) and e is co-prime to φ(n). The private key d is computed so that d × e ≡ 1 mod φ(n). The resulting public key is the pair (e, n), and the private key is (d, n), both of which are saved in separate files for later use.

To sign a document, the sender loads their private key and computes the SHA-256 hash of the document. This hash is then encrypted using the private key, creating a unique digital signature. The signature is saved to a file, often named signature.sig, and transmitted along with the original document. On the receiver’s end, the verification process involves loading the sender’s public key and recomputing the hash of the received document. The digital signature is decrypted using the public key to reveal the original hash generated by the sender. If this hash matches the newly computed hash, it confirms that the document is authentic and has not been altered.

The overall workflow of the project includes key generation, document signing, and signature verification. The sender generates RSA keys and stores them in JSON files such as private_key.json and public_key.json. The document is hashed and signed, and the resulting signature is stored in a file. The receiver then uses the public key to verify the document's integrity by checking whether the signature corresponds to the document’s actual content. If the hashes match, the document is deemed valid and trustworthy.

In conclusion, this project successfully demonstrates how digital signatures can be created and verified using the SHA-256 hashing algorithm and RSA encryption. It highlights the importance of combining hashing and encryption to achieve secure communication, ensuring that documents remain both untampered and authentic throughout transmission. The Python scripts included in this repository implement the complete workflow, from key generation to final verification.

